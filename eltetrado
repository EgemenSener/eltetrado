#! /usr/bin/env python3
import argparse
import itertools
import json
import os
import shutil
import string
import subprocess
import sys
import tempfile
from collections import defaultdict, Counter
from typing import Dict, Iterable, List, Tuple

__version__ = '0.0.2-dev8'

LW_SCORE = {
    'cWW': 1, 'tWW': 2, 'cWH': 3, 'tWH': 4, 'cWS': 5, 'tWS': 6,
    'cHW': 7, 'tHW': 8, 'cHH': 9, 'tHH': 10, 'cHS': 11, 'tHS': 12,
    'cSW': 13, 'tSW': 14, 'cSH': 15, 'tSH': 16, 'cSS': 17, 'tSS': 18
}


class Nucleotide:
    def __init__(self, nt: dict):
        self.id: str = nt['nt_id']
        self.code = nt['nt_code']
        self.index: int = nt['index']
        if self.id.find(':') != -1:
            self.chain: str = '{}:{}'.format(self.id.split(':')[0], nt['chain_name'])
        else:
            self.chain: str = nt['chain_name']

    def __hash__(self):
        return hash(self.id)

    def __lt__(self, other):
        return self.index < other.index

    def __str__(self):
        return self.id


class Pair:
    def __init__(self, nt1: Nucleotide, nt2: Nucleotide, lw: str, saenger: str):
        self.pair = (nt1, nt2)
        self.lw = lw
        self.saenger = saenger

    def __str__(self):
        return '{} {} {} {}'.format(self.pair[0], self.pair[1], self.lw, self.score())

    def conflicts_with(self, other):
        xi, yi = sorted((self.pair[0].index, self.pair[1].index))
        xj, yj = sorted((other.pair[0].index, other.pair[1].index))
        return xi < xj < yi < yj or xj < xi < yj < yi

    def reverse(self):
        lw = '{}{}{}'.format(self.lw[0], self.lw[2], self.lw[1])
        return Pair(self.pair[1], self.pair[0], lw, self.saenger)

    def score(self) -> int:
        return LW_SCORE.get(self.lw, 100)


class Tetrad:
    def __init__(self, nt1: Nucleotide, nt2: Nucleotide, nt3: Nucleotide, nt4: Nucleotide, pairs: dict):
        self.nucleotides = (nt1, nt2, nt3, nt4)
        self.pairs = [pairs[x] for x in ((nt1, nt2), (nt2, nt3), (nt3, nt4), (nt4, nt1))]
        self.direction = 'n/a'
        self.set = set(self.nucleotides)
        self._score = sum(x.score() for x in self.pairs)
        self._hash = hash(tuple(sorted(self.nucleotides)))

    def __hash__(self):
        return self._hash

    def __iter__(self):
        return iter(self.nucleotides)

    def __str__(self):
        return '    {} {} {} {} {}-{}-{}-{} {} {}\n'.format(self.nucleotides[0], self.nucleotides[1],
                                                            self.nucleotides[2], self.nucleotides[3], self.pairs[0].lw,
                                                            self.pairs[1].lw, self.pairs[2].lw, self.pairs[3].lw,
                                                            self.direction, self.get_classification())

    def stems_with(self, other) -> bool:
        index_diff = (j - i for i, j in zip(self.sorted_indices(), other.sorted_indices()))
        return all(abs(diff) == 1 for diff in index_diff)

    def count_non_stacked_bases(self, other, stacking: set) -> Tuple[int, int]:
        ti, tj = set(self.nucleotides), set(other.nucleotides)
        for stack in stacking:
            stack = set(stack)
            if not stack.isdisjoint(ti) and not stack.isdisjoint(tj):
                ti.difference_update(stack)
                tj.difference_update(stack)
        return len(ti), len(tj)

    def sorted_indices(self) -> list:
        return sorted(map(lambda x: x.index, self.nucleotides))

    def get_score(self) -> int:
        return self._score

    def is_disjoint(self, other) -> bool:
        return self.set.isdisjoint(other.set)

    def reorder(self):
        # transform into (0, 1, 2, 3)
        ni, nj, nk, nl = (nt.index for nt in self.nucleotides)
        indices = sorted((ni, nj, nk, nl))
        ni, nj, nk, nl = (indices.index(x) for x in (ni, nj, nk, nl))

        nmin = min(ni, nj, nk, nl)
        if nmin == ni:
            pass
        elif nmin == nj:
            self.nucleotides = self.nucleotides[1:4] + self.nucleotides[0:1]
            self.pairs = self.pairs[1:4] + self.pairs[0:1]
        elif nmin == nk:
            self.nucleotides = self.nucleotides[2:4] + self.nucleotides[0:2]
            self.pairs = self.pairs[2:4] + self.pairs[0:2]
        else:
            self.nucleotides = self.nucleotides[3:4] + self.nucleotides[0:3]
            self.pairs = self.pairs[3:4] + self.pairs[0:3]

        if self.pairs[0].score() < self.pairs[3].reverse().score():
            pass
        else:
            self.nucleotides = self.nucleotides[0:1] + tuple(reversed(self.nucleotides[1:]))
            self.pairs = tuple(self.pairs[i].reverse() for i in (3, 2, 1, 0))

        ni, nj, nk, nl = (nt.index for nt in self.nucleotides)
        assert ni == min(ni, nj, nk, nl)
        pi, pj, pk, pl = self.pairs
        assert pi.score() <= pl.reverse().score(), 'Conflicting multiplet {} and {}'.format(pi, pl.reverse())

    def get_classification(self) -> str:
        self.reorder()

        # transform into (0, 1, 2, 3)
        ni, nj, nk, nl = (nt.index for nt in self.nucleotides)
        indices = sorted((ni, nj, nk, nl))
        ni, nj, nk, nl = (indices.index(x) for x in (ni, nj, nk, nl))

        order = (nj, nk, nl)
        if order == (1, 2, 3):
            return 'O+'
        elif order == (3, 2, 1):
            return 'O-'
        elif order == (1, 3, 2):
            return 'N+'
        elif order == (2, 3, 1):
            return 'N-'
        elif order == (2, 1, 3):
            return 'Z+'
        elif order == (3, 1, 2):
            return 'Z-'
        else:
            raise Exception('Impossible combination: {} {} {} {}'.format(ni, nj, nk, nl))

    def chains(self) -> Counter:
        return Counter((nt.chain for nt in self.nucleotides))

    def determine_direction(self, other):
        # count directions 5' -> 3' as +1 or -1
        counter = Counter(1 if j - i > 0 else -1 for i, j in zip(self.sorted_indices(), other.sorted_indices()))
        direction, count = counter.most_common()[0]
        # all in the same direction
        if count == 4:
            self.direction = 'parallel'
        # two in +, one in - direction
        elif count == 2:
            self.direction = 'antiparallel'
        else:
            self.direction = 'hybrid'


class Quadruplex:
    def __init__(self, tetrads: List[Tetrad]):
        self.tetrads = tetrads

    def __str__(self):
        if len(self.tetrads) == 1:
            builder = '  single tetrad\n'
        else:
            builder = '  {}{} quadruplex with {} tetrads\n'.format(self._get_onzm(), self._get_direction(),
                                                                   len(self.tetrads))
        for tetrad in self.tetrads:
            builder += str(tetrad)
        return builder

    def _get_onzm(self) -> str:
        classifications = [t.get_classification()[0] for t in self.tetrads]
        if 'n/a' in classifications:
            return 'U'
        counter = Counter(classifications)
        onz, support = counter.most_common()[0]
        if support == len(self.tetrads):
            return onz[0]  # O, N or Z
        return 'M'

    def _get_direction(self) -> str:
        if len(self.tetrads) == 1:
            return 'n/a'
        else:
            counter = Counter((t.direction for t in self.tetrads[1:]))
            direction, support = counter.most_common()[0]
            if support == len(self.tetrads) - 1:
                return direction[0]
            return 'h'


class Helix:
    def __init__(self, tetrads: List[Tetrad]):
        self.tetrads = tetrads
        self.quadruplexes = []

    def __iter__(self):
        return iter(self.tetrads)

    def __str__(self):
        if len(self.tetrads) > 1:
            builder = 'n4-helix with {} tetrads\n'.format(len(self.tetrads))
        else:
            builder = 'single tetrad without stacking\n'
        for quadruplex in self.quadruplexes:
            builder += str(quadruplex)
        return builder

    def find_quadruplexes(self):
        quadruplexes = []
        tetrads = []
        for tetrad in sorted(self.tetrads, key=lambda t: min(nt.index for nt in t.nucleotides)):
            if tetrads:
                if tetrad.chains() == tetrads[-1].chains():
                    tetrad.determine_direction(tetrads[-1])
                else:
                    quadruplexes.append(Quadruplex(tetrads))
                    tetrads = []
            tetrads.append(tetrad)
        quadruplexes.append(Quadruplex(tetrads))
        self.quadruplexes = quadruplexes


class Structure:
    def __init__(self, data: dict):
        self.nucleotides: Dict[str, Nucleotide] = {nt['nt_id']: Nucleotide(nt) for nt in data['nts']}
        self.stacking = {tuple(self.nucleotides[nt] for nt in stack['nts_long'].split(',')) for stack in data['stacks']}
        self.pairs = self._read_pairs(data)
        self.canonical = {pair for pair in self.pairs.values() if pair.saenger in ('19-XIX', '20-XX', '28-XXVIII')}
        self.graph = dict()
        self.tetrads = set()
        self.stems = dict()
        self.stacks = dict()
        self.helices = list()
        self.sequence = ''
        self.dotbracket = ('', '')

    def __str__(self):
        builder = 'Chain order: {}\n'.format(', '.join(self.chain_order()))
        for helix in self.helices:
            builder += str(helix)
        builder += '{}\n{}\n{}'.format(self.sequence, *self.dotbracket)
        return builder

    def build_graph(self, strict: bool):
        graph = defaultdict(list)
        for pair in self.pairs.values():
            if strict and pair.lw not in ('cWH', 'cHW'):
                continue
            nt1, nt2 = pair.pair
            graph[nt1].append(nt2)
        self.graph = graph

    def find_tetrads(self):
        # search for a tetrad: i -> j -> k -> l
        #                      ^--------------^
        tetrads = set()
        for i in self.graph:
            for j in filter(lambda x: x != i, self.graph[i]):
                for k in filter(lambda x: x not in (i, j), self.graph[j]):
                    for l in filter(lambda x: x not in (i, j, k) and x in self.graph[i], self.graph[k]):
                        tetrads.add(Tetrad(i, j, k, l, self.pairs))

        # when two tetrads share some of the nucleotides, remove the one which has worse score
        flag = True
        while flag:
            for (ti, tj) in itertools.combinations(tetrads, 2):
                if not ti.is_disjoint(tj):
                    if ti.get_score() < tj.get_score():
                        tetrads.remove(tj)
                    else:
                        tetrads.remove(ti)
                    break
            else:
                flag = False
        self.tetrads = tetrads

    def find_stems(self):
        stems = defaultdict(list)
        for ti, tj in itertools.combinations(self.tetrads, 2):
            if ti.stems_with(tj):
                stems[ti].append(tj)
                stems[tj].append(ti)
        self.stems = stems

    def find_stacks(self, stacking_mismatch: int):
        stackings = defaultdict(list)
        for ti, tj in itertools.combinations(self.tetrads, 2):
            i, j = ti.count_non_stacked_bases(tj, self.stacking)
            if i <= stacking_mismatch and j <= stacking_mismatch:
                stackings[ti].append(tj)
                stackings[tj].append(ti)
        self.stacks = stackings

    def find_helices(self, relaxed_stem_definition: bool):
        helices = list()
        candidates = set(self.tetrads)
        while candidates:
            tetrads = [candidates.pop()]
            changed = True
            while changed:
                changed = False
                for tetrad in tetrads:
                    for stacked in filter(lambda x: x in candidates, self.stacks.get(tetrad, [])):
                        tetrads.append(stacked)
                        candidates.remove(stacked)
                        changed = True
                    if relaxed_stem_definition:
                        for stemmed in filter(lambda x: x in candidates, self.stems.get(tetrad, [])):
                            tetrads.append(stemmed)
                            candidates.remove(stemmed)
                            changed = True
            helices.append(Helix(tetrads))
        self.helices = helices

    def find_best_chain_reorder(self):
        scores = {'O+': 0, 'O-': 1, 'N+': 2, 'N-': 3, 'Z+': 4, 'Z-': 5}
        chain_groups = self._group_related_chains()
        final_order = []

        for chains in filter(lambda x: len(x) > 1, chain_groups):
            best_permutation, best_score = chains, 1e10
            for permutation in sorted(itertools.permutations(chains)):
                self._reorder_chains(permutation)
                classification = list(self._get_classification())
                score = sum(scores[c] for c in classification)
                # print('Checking reorder:', ', '.join(permutation), ''.join(classification))
                if score < best_score:
                    best_score = score
                    best_permutation = permutation
            final_order.extend(best_permutation)

        if final_order:
            self._reorder_chains(final_order)
            classification = list(self._get_classification())
            # print('Selected reorder:', ', '.join(final_order), ''.join(classification))

    def find_quadruplexes(self):
        for helix in self.helices:
            helix.find_quadruplexes()

    def chain_order(self) -> Iterable[str]:
        return {nt.chain: 0 for nt in sorted(self.nucleotides.values(), key=lambda nt: nt.index)}

    def compute_twoline_dotbracket(self):
        layer1, layer2 = [], []
        for tetrad in self.tetrads:
            layer1.extend((tetrad.pairs[0], tetrad.pairs[2]))
            layer2.extend((tetrad.pairs[1], tetrad.pairs[3]))
        self.sequence, self.dotbracket = self._elimination_conflicts(layer1)
        self.dotbracket = (self.dotbracket, self._elimination_conflicts(layer2)[1])

    def visualize(self, inputname: str, canonical: bool):
        tempdir = os.path.join(tempfile.gettempdir(), '.eltetrado')
        os.makedirs(tempdir, exist_ok=True)

        output_name = os.path.splitext(os.path.basename(inputname))[0]
        fd, fasta = tempfile.mkstemp('.fasta', dir=tempdir)
        os.close(fd)
        with open(fasta, 'w') as fastafile:
            fastafile.write('>{}\n'.format(output_name))
            fastafile.write(''.join(self.sequence))

        layer1, layer2 = [], []
        for tetrad in self.tetrads:
            layer1.extend((tetrad.pairs[0], tetrad.pairs[2]))
            layer2.extend((tetrad.pairs[1], tetrad.pairs[3]))
        helix1 = self._to_helix(layer1, tempdir, canonical)
        helix2 = self._to_helix(layer2, tempdir)

        currdir = os.path.dirname(os.path.realpath(__file__))
        output_pdf = '{}.pdf'.format(output_name)
        run = subprocess.run([os.path.join(currdir, 'quadraw.R'), fasta, helix1, helix2, output_pdf],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print()
        if run.returncode == 0:
            print('Plot:', output_pdf)
        else:
            print('Failed to prepare visualization, reason:\n  {}'.format(run.stderr.decode('utf-8')))

    def _to_helix(self, layer: List[Pair], tempdir: str, canonical: bool = False):
        onz = dict()
        for tetrad in self.tetrads:
            onz.update({pair: tetrad.get_classification() for pair in tetrad.pairs})

        fd, name = tempfile.mkstemp('.helix', dir=tempdir)
        os.close(fd)
        onz_value = {'O+': 1, 'O-': 2, 'N+': 3, 'N-': 4, 'Z+': 5, 'Z-': 6, 'n/a': 7}
        nucleotides = sorted(self.nucleotides.values())

        with open(name, 'w') as helixfile:
            helixfile.write('#{}\n'.format(len(self.sequence) + 1))
            helixfile.write('i\tj\tlength\tvalue\n')
            for pair in layer:
                x, y = pair.pair
                x, y = nucleotides.index(x) + 1, nucleotides.index(y) + 1
                helixfile.write('{}\t{}\t1\t{}\n'.format(x, y, onz_value[onz[pair]]))
            if canonical:
                for pair in self.canonical:
                    x, y = pair.pair
                    x, y = nucleotides.index(x) + 1, nucleotides.index(y) + 1
                    helixfile.write('{}\t{}\t1\t8\n'.format(x, y))
        return name

    def _elimination_conflicts(self, pairs: List[Pair]) -> Tuple[str, str]:
        orders = dict()
        order = 0
        queue = list(pairs)
        removed = []

        while queue:
            conflicts = defaultdict(list)
            for pi, pj in itertools.combinations(queue, 2):
                if pi.conflicts_with(pj):
                    conflicts[pi].append(pj)
                    conflicts[pj].append(pi)
            if conflicts:
                pair, _ = sorted(conflicts.items(), key=lambda x: len(x[1]), reverse=True)[0]
                removed.append(pair)
                queue.remove(pair)
            else:
                orders.update({pair: order for pair in queue})
                queue, removed = removed, []
                order += 1

        opening = '([{<' + string.ascii_uppercase
        closing = ')]}>' + string.ascii_lowercase
        dotbracket = dict()
        for pair, order in orders.items():
            nt1, nt2 = sorted(pair.pair)
            dotbracket[nt1] = opening[order]
            dotbracket[nt2] = closing[order]

        sequence = ''
        structure = ''
        chain = None
        for nt in sorted(self.nucleotides.values()):
            if chain and chain != nt.chain:
                sequence += '-'
                structure += '-'
            sequence += nt.code
            structure += dotbracket.get(nt, '.')
            chain = nt.chain
        return sequence, structure

    def _reorder_chains(self, chain_order: Iterable):
        i = 1
        for chain in chain_order:
            for nt in self.nucleotides.values():
                if nt.chain == chain:
                    nt.index = i
                    i += 1
        for nt in self.nucleotides.values():
            if nt.chain not in chain_order:
                nt.index = i
                i += 1
        for tetrad in self.tetrads:
            tetrad.reorder()

    def _group_related_chains(self):
        chains = dict()
        for q in self.helices:
            chains[q] = {n.chain for t in q.tetrads for n in t.nucleotides}
        changed = True
        while changed:
            changed = False
            for q1, q2 in itertools.combinations(chains.keys(), 2):
                if not chains[q1].isdisjoint(chains[q2]):
                    chains[q1].update(chains[q2])
                    del chains[q2]
                    changed = True
                    break
        return chains.values()

    def _get_classification(self):
        for q in self.helices:
            for t in q.tetrads:
                yield t.get_classification()

    def _read_pairs(self, data: dict) -> Dict[Tuple[Nucleotide, Nucleotide], Pair]:
        pairs = dict()
        for pair in data['pairs']:
            nt1, nt2, lw, saenger = pair['nt1'], pair['nt2'], pair['LW'], pair['Saenger']
            nt1, nt2 = self.nucleotides[nt1], self.nucleotides[nt2]
            pair = Pair(nt1, nt2, lw, saenger)
            pairs[(nt1, nt2)] = pair
            pairs[(nt2, nt1)] = pair.reverse()
        return pairs


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('--json', action='store_true', help='parse input file from JSON format')
    parser.add_argument('--stacking-mismatch',
                        help='a perfect tetrad stacking covers 4 nucleotides; this option can be used with value 1 or '
                             '2 to allow this number of nucleotides to be non-stacked with otherwise well aligned '
                             'tetrad [default=2]',
                        default=2)
    parser.add_argument('--relaxed-stem-definition', action='store_true',
                        help='when set, two sequentially close tetrades will be considered a stem regardless of their '
                             'stacking')
    parser.add_argument('--strict', action='store_true',
                        help='nucleotides in tetrad are found when linked only by cWH pairing')
    parser.add_argument('--no-reorder', action='store_true',
                        help='chains of bi- and tetramolecular quadruplexes are reordered to be able to have them '
                             'classified; when this is set, chains will be processed in original order and '
                             'bi-/tetramolecular quadruplexes will not be classified')
    parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
    parser.add_argument('--complete-2d', action='store_true',
                        help='when set, the visualization will also show canonical base pairs to provide context for '
                             'the quadruplex')
    parser.add_argument('--no-image', action='store_true',
                        help='when set, the visualization will not be created at all')
    parser.add_argument('input',
                        help='a JSON file produced by DSSR if "--json" is used, otherwise a PDB or PDBx/MMCIF file to '
                             'be analyzed first by DSSR')
    return parser.parse_args()


def load_dssr_results(args):
    if args.json:
        with open(args.input) as jsonfile:
            dssr = jsonfile.read()
    else:
        currdir = os.path.dirname(os.path.realpath(__file__))
        tempdir = tempfile.mkdtemp()
        shutil.copy(os.path.join(currdir, 'x3dna-dssr'), tempdir)
        shutil.copy(args.input, tempdir)
        dssr = subprocess.Popen(
            ['./x3dna-dssr', '-i={}'.format(os.path.basename(args.input)), '--json', '--symmetry'],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=tempdir)
        dssr, _ = dssr.communicate()
        shutil.rmtree(tempdir)

    try:
        return json.loads(dssr)
    except json.JSONDecodeError:
        print('Invalid JSON in', args.input, file=sys.stderr)
        exit(1)


if __name__ == '__main__':
    args = parse_arguments()
    args.stacking_mismatch = int(args.stacking_mismatch)
    dssr = load_dssr_results(args)

    if 'pairs' not in dssr:
        print('None')
        exit()

    structure = Structure(dssr)
    structure.build_graph(args.strict)
    structure.find_tetrads()

    if not structure.tetrads:
        print('None')
        exit()

    structure.find_stems()
    structure.find_stacks(args.stacking_mismatch)
    structure.find_helices(args.relaxed_stem_definition)
    structure.find_quadruplexes()

    if not structure.helices:
        print('None')
        exit()

    if not args.no_reorder:
        structure.find_best_chain_reorder()

    structure.compute_twoline_dotbracket()
    print(structure)

    if not args.no_image:
        structure.visualize(args.input, args.complete_2d)
