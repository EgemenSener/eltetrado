#! /usr/bin/env python3
import argparse
import collections
import itertools
import json
import os
import subprocess
import shutil
import string
import sys
import tempfile

__version__ = '0.0.2-dev6'

def index(nt):
    return nt['index']

def classify_onz(nts, tetrad, reordered):
    distinct_chain_count = len(set([nts[i]['chain_name'] for i in tetrad]))
    classification = 'n/a'
    if distinct_chain_count == 1 or reordered:
        n1 = index(nts[tetrad[0]])
        n2 = index(nts[tetrad[1]])
        n3 = index(nts[tetrad[2]])
        n4 = index(nts[tetrad[3]])

        nmin = min(n1, n2, n3, n4)
        if nmin == n1:
            pass
        elif nmin == n2:
            n1, n2, n3, n4 = n2, n3, n4, n1
        elif nmin == n3:
            n1, n2, n3, n4 = n3, n4, n1, n2
        else:
            n1, n2, n3, n4 = n4, n1, n2, n3

        if n2 < n3 and n3 < n4:
            classification = 'O+'
        elif n2 > n3 and n3 > n4:
            classification = 'O-'
        elif n2 < n3 and n2 < n4:
            classification = 'N+'
        elif n2 < n3 and n2 > n4:
            classification = 'N-'
        elif n2 > n3 and n2 < n4:
            classification = 'Z+'
        elif n2 > n3 and n2 > n4:
            classification = 'Z-'
    return classification

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--json', action='store_true', help='parse input file from JSON format')
    parser.add_argument('--stacking-mismatch', help='a perfect tetrad stacking covers 4 nucleotides; this option can be used with value 1 or 2 to allow this number of nucleotides to be non-stacked with otherwise well aligned tetrad [default=2]', default=2)
    parser.add_argument('--relaxed-stem-definition', action='store_true', help='when set, two sequentially close tetrades will be considered a stem regardless of their stacking')
    parser.add_argument('--strict', action='store_true', help='nucleotides in tetrad are found when linked only by cWH pairing')
    parser.add_argument('--reorder', action='store_true', help='when set, chains will be internally reordered to allow classification of bi- and tetramolecular structures')
    parser.add_argument('--version', action='version', version='%(prog)s {}'.format(__version__))
    parser.add_argument('input', help='a JSON file produced by DSSR if "--json" is used, otherwise a PDB or PDBx/MMCIF file to be analyzed first by DSSR')
    args = parser.parse_args()

    stacking_mismatch = int(args.stacking_mismatch)
    currdir = os.path.dirname(os.path.realpath(__file__))

    if args.json:
        with open(args.input) as jsonfile:
            dssr = jsonfile.read()
    else:
        tempdir = tempfile.mkdtemp()
        shutil.copy(os.path.join(currdir, 'x3dna-dssr'), tempdir)
        shutil.copy(args.input, tempdir)
        dssr = subprocess.Popen(['./x3dna-dssr', '-i={}'.format(os.path.basename(args.input)), '--json', '--symmetry'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=tempdir)
        dssr, _ = dssr.communicate()
        shutil.rmtree(tempdir)

    try:
        data = json.loads(dssr)
    except:
        print('Invalid JSON in', args.input, file=sys.stderr)
        exit(1)

    if 'pairs' not in data:
        print('None')
        exit()

    nts = dict()
    for nt in data['nts']:
        nt_id = nt['nt_id']
        if nt_id.find(':') != -1:
            nt['chain_name'] = '{}:{}'.format(nt_id.split(':')[0], nt['chain_name'])
        nts[nt_id] = nt

    stacks = list()
    for stack in data['stacks']:
        stacks.append(stack['nts_long'].split(','))

    cwh = dict()
    for pair in data['pairs']:
        lw = pair['LW']
        nt1 = nts[pair['nt1']]['nt_id']
        nt2 = nts[pair['nt2']]['nt_id']
        if lw == 'cWH':
            if nt1 not in cwh:
                cwh[nt1] = list()
            cwh[nt1].append(nt2)

    for pair in data['pairs']:
        lw = pair['LW']
        nt1 = nts[pair['nt1']]['nt_id']
        nt2 = nts[pair['nt2']]['nt_id']
        if lw == 'cHW':
            if nt2 not in cwh:
                cwh[nt2] = list()
            cwh[nt2].append(nt1)

    if not args.strict:
        for pair in data['pairs']:
            lw = pair['LW']
            nt1 = nts[pair['nt1']]['nt_id']
            nt2 = nts[pair['nt2']]['nt_id']
            if nt1 not in cwh:
                cwh[nt1] = list()
            cwh[nt1].append(nt2)
            if nt2 not in cwh:
                cwh[nt2] = list()
            cwh[nt2].append(nt1)

    # search for a tetrad: i -> j -> k -> l -> i
    used = set()
    tetrads = list()
    for i in cwh:
        for j in [j for j in cwh[i] if j in cwh and j not in (i)]:
            for k in [k for k in cwh[j] if k in cwh and k not in (i, j)]:
                for l in [l for l in cwh[k] if l in cwh and l not in (i, j, k) and i in cwh[l]]:
                    if any([i in used, j in used, k in used, l in used]):
                        continue
                    ni, nj, nk, nl = index(nts[i]), index(nts[j]), index(nts[k]), index(nts[l])
                    nmin = min(ni, nj, nk, nl)
                    if ni == nmin:
                        tetrad = (i, j, k, l)
                    elif nj == nmin:
                        tetrad = (j, k, l, i)
                    elif nk == nmin:
                        tetrad = (k, l, i, j)
                    else:
                        tetrad = (l, i, j, k)
                    tetrads.append(tetrad)
                    used.update(tetrad)

    def check_tetrads_stem(ti, tj):
        ti = [index(nts[nt]) for nt in ti]
        tj = [index(nts[nt]) for nt in tj]
        index_diff = [j - i for i, j in zip(ti, tj)]
        return all([abs(diff) == 1 for diff in index_diff])

    stems = dict()
    for ti, tj in itertools.combinations(tetrads, 2):
        if check_tetrads_stem(ti, tj):
            if not ti in stems:
                stems[ti] = list()
            stems[ti].append(tj)
            if not tj in stems:
                stems[tj] = list()
            stems[tj].append(ti)

    def check_tetrads_stacking(ti, tj):
        ti, tj = set(ti), set(tj)
        for stack in stacks:
            stack = set(stack)
            if not stack.isdisjoint(ti) and not stack.isdisjoint(tj):
                ti.difference_update(stack)
                tj.difference_update(stack)
        return len(ti) <= stacking_mismatch and len(tj) <= stacking_mismatch

    stackings = dict()
    for ti, tj in itertools.combinations(tetrads, 2):
        if check_tetrads_stacking(ti, tj):
            if not ti in stackings:
                stackings[ti] = list()
            stackings[ti].append(tj)
            if not tj in stackings:
                stackings[tj] = list()
            stackings[tj].append(ti)

    quadruplexes = list()
    candidates = set(tetrads)
    while candidates:
        quadruplex = [candidates.pop()]
        changed = True
        while changed:
            changed = False
            for tetrad in quadruplex:
                if tetrad in stackings:
                    for stacked in stackings[tetrad]:
                        if stacked in candidates:
                            quadruplex.append(stacked)
                            candidates.remove(stacked)
                            changed = True
                if args.relaxed_stem_definition and tetrad in stems:
                    for stemmed in stems[tetrad]:
                        if stemmed in candidates:
                            quadruplex.append(stemmed)
                            candidates.remove(stemmed)
                            changed = True
        quadruplexes.append(quadruplex)

    if len(quadruplexes) == 0:
        print('None')
        exit()

    quadruplexes.sort(key=lambda x: len(x), reverse=True)

    def apply_chain_reordering(nts, chain_order):
        i = 1
        for chain in chain_order:
            for nt in nts:
                if nts[nt]['chain_name'] == chain:
                    nts[nt]['index'] = i
                    i += 1
        for nt in nts:
            if nts[nt]['chain_name'] not in chain_order:
                nts[nt]['index'] = i
                i += 1

    if args.reorder:
        chains_set = set()
        for quadruplex in quadruplexes:
            previous_chains = None
            for tetrad in quadruplex:
                current_chains = collections.Counter([nts[nt]['chain_name'] for nt in tetrad])
                if previous_chains and previous_chains != current_chains:
                    chains_set.add(tuple(set(previous_chains.elements())))
                previous_chains = current_chains
            chains_set.add(tuple(set(current_chains.elements())))

        candidates = list(chains_set)
        chains_set = list()
        while candidates:
            chain_set = set(candidates.pop())
            to_remove = list()
            for i, chains in enumerate(candidates):
                if not chain_set.isdisjoint(set(chains)):
                    chain_set.update(set(chains))
                    to_remove.append(i)
            for i in sorted(to_remove, reverse=True):
                del(candidates[i])
            chains_set.append(chain_set)

        previous_best = []
        for chains in chains_set:
            best_score = {'O+': -1, 'O-': -1, 'N+': -1, 'N-': -1, 'Z+': -1, 'Z-': -1}
            best_permutation = None
            best_description = ''
            n = len(tetrads)
            reorderings = set()
            for permutation in sorted(itertools.permutations(chains)):
                apply_chain_reordering(nts, previous_best + list(permutation))
                score = {'O+': 0, 'O-': 0, 'N+': 0, 'N-': 0, 'Z+': 0, 'Z-': 0}
                description = list()
                for tetrad in tetrads:
                    onz = classify_onz(nts, tetrad, True)
                    score[onz] += 1
                    description.append(onz)
                description = tuple(description)
                if description not in reorderings:
                    print('Possible reordering:', ''.join(description))
                    reorderings.add(description)

                def value(s):
                    value = 0
                    for x in ('O+', 'O-', 'N+', 'N-', 'Z+', 'Z-'):
                        value += s[x]
                        value *= len(tetrads)
                    return value

                if value(score) > value(best_score):
                    best_score = score
                    best_permutation = permutation
                    best_description = description

            print('Selected reordering:', ''.join(best_description))
            apply_chain_reordering(nts, previous_best + list(best_permutation))
            previous_best = previous_best + list(best_permutation)

    print('Chain order:', ', '.join(previous_best))
    print()
    classification_map = dict()

    for quadruplex in quadruplexes:
        if len(quadruplex) > 1:
            print('n4-helix with {} tetrads'.format(len(quadruplex)))
        else:
            print('single tetrad without stacking')

        quadruplex = list(quadruplex)
        quadruplex.sort(key=lambda x: index(nts[x[0]]))

        previous_chains = None
        previous = []
        classified = []
        direction = 'n/a'
        votes_direction = {'parallel': 0, 'antiparallel': 0, 'hybrid' : 0}
        votes_classification = {'O' : 0, 'N' : 0, 'Z' : 0, 'n/a' : 0}

        for tetrad in quadruplex:
            current_chains = collections.Counter([nts[nt]['chain_name'] for nt in tetrad])
            current = [index(nts[nt]) for nt in tetrad]
            if previous:
                index_diff = [j - i for i, j in zip(sorted(previous), sorted(current))]
                is_stem = previous_chains == current_chains
                is_parallel = len(set(index_diff) - {1, 2, 3}) == 0 or len(set(index_diff) - {-1, -2, -3}) == 0
                is_antiparallel = not is_parallel \
                        and len(set(index_diff) - {1, -1, 2, -2, 3, -3}) == 0 \
                        and collections.Counter([1 if i > 0 else -1 for i in index_diff]).most_common()[0][1] == 2
                if is_stem:
                    direction = 'parallel' if is_parallel else 'antiparallel' if is_antiparallel else 'hybrid'
                    votes_direction[direction] += 1
                if not is_stem:
                    if len(classified) == 1:
                        print('  single tetrad')
                    else:
                        votes_direction = sorted(votes_direction.items(), key=lambda x: x[1], reverse=True)
                        # clear winner
                        if votes_direction[1][1] == 0:
                            stem_type = votes_direction[0][0]
                        else:
                            stem_type = 'hybrid'

                        votes_classification = sorted(votes_classification.items(), key=lambda x: x[1], reverse=True)
                        # clear winner
                        if votes_classification[1][1] == 0:
                            classification_type = votes_classification[0][0]
                        else:
                            classification_type = 'M' # Mixed
                        if classification_type == 'n/a':
                            classification_type = 'U' # Unknown

                        print('  {}{} quadruplex with {} tetrads'.format(classification_type[0], stem_type[0], len(classified)))
                    print('\n'.join(classified))
                    classified = []
                    votes_direction = {'parallel': 0, 'antiparallel': 0, 'hybrid' : 0}
                    votes_classification = {'O' : 0, 'N' : 0, 'Z' : 0, 'n/a' : 0}
            previous_chains = current_chains
            previous = current

            classification = classify_onz(nts, tetrad, args.reorder)
            classification_map[tetrad] = classification
            votes_classification[classification.replace('-', '').replace('+', '')] += 1
            classified.append('    {} {} {} {} {} {}'.format(tetrad[0], tetrad[1], tetrad[2], tetrad[3], direction, classification))

        if len(classified) == 1:
            print('  single tetrad')
        else:
            votes_direction = sorted(votes_direction.items(), key=lambda x: x[1], reverse=True)
            # clear winner
            if votes_direction[1][1] == 0:
                stem_type = votes_direction[0][0]
            else:
                stem_type = 'hybrid'

            votes_classification = sorted(votes_classification.items(), key=lambda x: x[1], reverse=True)
            # clear winner
            if votes_classification[1][1] == 0:
                classification_type = votes_classification[0][0]
            else:
                classification_type = 'M' # Mixed
            if classification_type == 'n/a':
                classification_type = 'U' # Unknown

            print('  {}{} quadruplex with {} tetrads'.format(classification_type[0], stem_type[0], len(classified)))
        print('\n'.join(classified))

    layer1 = list()
    layer2 = list()
    for quadruplex in quadruplexes:
        for tetrad in quadruplex:
            classification = classification_map[tetrad]
            tetrad = tuple(map(lambda nt: index(nts[nt]), tetrad))
            layer1.append(sorted([tetrad[0], tetrad[1]]) + [classification])
            layer1.append(sorted([tetrad[2], tetrad[3]]) + [classification])
            layer2.append(sorted([tetrad[0], tetrad[3]]) + [classification])
            layer2.append(sorted([tetrad[1], tetrad[2]]) + [classification])

    rev = {index(nts[nt]): nt for nt in nts}
    previous_chain = nts[rev[sorted(rev)[0]]]['chain_name']
    shift = dict()
    value = 0
    sequence = list()

    for i in sorted(rev):
        nt = rev[i]
        current_chain = nts[nt]['chain_name']
        if current_chain != previous_chain:
            sequence.append('-')
            value += 1
        previous_chain = current_chain
        shift[i] = value
        sequence.append(nts[nt]['nt_code'])

    tempdir = os.path.join(tempfile.gettempdir(), '.eltetrado')
    os.makedirs(tempdir, exist_ok=True)

    output_name = os.path.splitext(os.path.basename(args.input))[0]
    fd, fasta = tempfile.mkstemp('.fasta', dir=tempdir)
    os.close(fd)
    with open(fasta, 'w') as fastafile:
        fastafile.write('>{}\n'.format(output_name))
        fastafile.write(''.join(sequence))

    def to_helix(layer):
        fd, name = tempfile.mkstemp('.helix', dir=tempdir)
        os.close(fd)
        onz_value = {'O+': 1, 'O-': 2, 'N+': 3, 'N-': 4, 'Z+': 5, 'Z-': 6, 'n/a': 7}
        with open(name, 'w') as helixfile:
            helixfile.write('#{}\n'.format(max(rev) + shift[max(rev)]))
            helixfile.write('i\tj\tlength\tvalue\n')
            for x, y, onz in layer:
                x += shift[x]
                y += shift[y]
                helixfile.write('{}\t{}\t1\t{}\n'.format(x, y, onz_value[onz]))
        return name

    helix1 = to_helix(layer1)
    helix2 = to_helix(layer2)
    output_pdf = '{}.pdf'.format(output_name)
    subprocess.run([os.path.join(currdir, 'mp.R'), fasta, helix1, helix2, output_pdf], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print()
    print('Plot:', output_pdf)

    brackets = ('([{<' + string.ascii_uppercase, ')]}>' + string.ascii_lowercase)

    def fcfs(pairs):
        pairs = sorted(pairs, key=lambda x: x[1])
        order = dict()
        for i in range(len(pairs)):
            xi, yi = pairs[i][0], pairs[i][1]
            conflicts = 0
            for j in range(i):
                xj, yj = pairs[j][0], pairs[j][1]
                if (xi < xj < yi < yj) or (xj < xi < yj < yi):
                    conflicts = max(conflicts, order[xj][0] + 1)
            order[xi] = conflicts, brackets[0][conflicts]
            order[yi] = conflicts, brackets[1][conflicts]
        return order

    layer1 = fcfs(layer1)
    layer2 = fcfs(layer2)
    sequence = list()
    dbn1 = list()
    dbn2 = list()
    previous_chain = nts[rev[sorted(rev)[0]]]['chain_name']

    for i in sorted(rev):
        nt = rev[i]
        current_chain = nts[nt]['chain_name']
        if current_chain != previous_chain:
            sequence.append('-')
            dbn1.append('-')
            dbn2.append('-')
        sequence.append(nts[nt]['nt_code'])
        if i in layer1:
            dbn1.append(layer1[i][1])
        else:
            dbn1.append('.')
        if i in layer2:
            dbn2.append(layer2[i][1])
        else:
            dbn2.append('.')
        previous_chain = current_chain

    print()
    print(''.join(sequence))
    print(''.join(dbn1))
    print(''.join(dbn2))
